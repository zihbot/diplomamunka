%----------------------------------------------------------------------------
\chapter{Bayes-döntés alapján diszkretizáló modul}\label{chapter:modul}
%----------------------------------------------------------------------------
% végére szekvenciadiagrammok, összehasonlítva az előző fejezet algoritmusával

\iffalse
A Diplomamunka részeként elkészült egy \textit{python} modul\footnote{A python nevezéktanban a függvénykönyvtárakat nevezik moduloknak.}, amely a bemutatott algoritmus használatát könnyíti meg. Az eredeti cikkben bemutatott implementáció \textit{julia} nyelven történt, amely egy gyors és dinamikusan fejlődő nyelv, melyet statisztikai feladatok megoldására gyakran használnak. Az új modul a python nyelven íródott, mert jelenleg ez a nyelv elterjedtebb, és az egyik jelentős előnye, hogy nagy mennyiségű függvénykönyvtárral rendelkezik, és ennek a bővítése segítség lehet a többi felhasználónak.

A modul célja, hogy egy robusztus többváltozós diszkretizációt hajtson végre a kapott adatsoron, valamint a kinyerhető információkat a felhasználó rendelkezésére bocsássa. A \verb|bediscretizer| név a "Bayesian Estimation based DISCRETIZER" rövidítése.

\section{Telepítés}
A modul jelenleg nem telepíthető pip-pel. Az \ref{appendix:codebase} függelékben szereplő linkről letölthető a bediscretizer könyvtár. Ezt a python HOME könyvtárának (például: \verb|C:\Python39|) \verb|Lib| alkönyvtárába bemásolva a modul telepítésre került.

\section{Használat}
Ha a modul telepítve van, a hozzá tartozó python értelmezőben futtatott \verb|import bediscretizer| parancs után felhasználhatóak a biztosított függvények.

A modul központi osztálya a \verb|MultivariateDiscretizer|. Példányosításkor meg kell adni a statisztikai adatsort egy numpy tömbként. Ezen kívül megadható az adatsor neve, amelyet később a kiírásokhoz használ.

Ezután a \verb|fit()| függvényének meghívásával lehet a tanító algoritmust futtatni. Ennek megadható, hány alkalommal futtassa a diszkretizáció és struktúra tanulási algoritmusokat, ez az epochok száma.
A futtatás után kinyerhetőek az adatok a modellből. Egy egyszerű példa látható a \ref{appendix:simpleexample} függelékben.

\section{Elérhető információk}
A \verb|MultivariateDiscretizer| osztályból az adatsorról sok adat kinyerhető. Ezeknek a listája, és a hozzájuk tartozó leírás szerepel itt.

\subsection{Tagváltozók}
\begin{itemize}
    \item[data] A megadott adatsor az előfeldolgozás után. Egy mátrix csak számokkal feltöltve.
    \item[column\_types] Az automatikusan felismert változótípus, amely lehet \verb|DISCRETE| vagy \verb|CONTINUOUS|.
    \item[discretization] A folytonos változókhoz tartozó diszkretizációs intervallumok határai.
    \item[graph] Az adatsorhoz illesztett gráf.
    \item[name] Az adatsor neve, amelyet az adatsorból kinyert adatok kijelzéséhez használ.
\end{itemize}

\subsection{Metódusok}
\begin{itemize}
    \setlength{\itemindent}{5em}
    \item[fit] A tanító algoritmus futását indítja el.
    \item[show] Az aktív \verb|pyplot figure| grafikonjára kirajzolja az illesztett gráfot.
    \item[draw\_structure\_to\_file] A paraméterként megadott fájlba menti az illesztett gráf képét.
    \item[as\_dataframe] Az adatsort \verb|pandas DataFrame| típusúként adja vissza.
\end{itemize}
\fi

Ez a fejezet bemutatja a Diplomamunka részeként elkészült bediscretizer csomag implementációját. Leírja, milyen elvárások, követelmények vannak a függvénykönyvtárral szemben. Ismerteti a mérnöki döntéseket, amelyeket a csomag létrehozásakor kellett meghozni.

A csomag python nyelven lett implementálva. Elsődleges célja, hogy egy robusztus többváltozós diszkretizációt hajtson végre a kapott adatsoron. A \verb|bediscretizer| név a "Bayesian Estimation based DISCRETIZER" rövidítése.

%% spellcheck-off
\section{Követelmények}
A csomaggal szemben támasztott követelmények a FURPS modell \cite{grady1992practical} szerint vannak csoportosítva. Ez egy angol betűszó, amely a csoportok neveinek kezdőbetűiből lett összerakva. Ezek alapján a program különböző szempontokból vizsgálható. A szempontok: funkcionalitás (\textbf{F}unctionality), használhatóság (\textbf{U}sability), megbízhatóság (\textbf{R}eliability), teljesítmény (\textbf{P}erformance) és a támogatottság (\textbf{S}upportability). Egy alkalmazás készítése során ezekre a szempontokra figyelve jobb minőségű végeredmény érhető el, mintha kizárólag a megfelelő működés a cél.
%% spellcheck-on

\subsection{Funkcionális követelmények}
A működés során az elvégzendő feladatokat, a rendszer képességeit, biztonsági kérdéseket válaszolja meg.

\begin{enumerate}
    \descitem{Bemenet} Fogadjon el numpy.ndarray típusú objektumot, amely az adatokat tartalmazza.
    \descitem{Kimenet} Legyen egy betanított Bayes-háló, amely a kapott adatok közötti kapcsolatokat reprezentálja.
    \descitem{Algoritmus} Valósítja meg a \autoref{chapter:bayesdontesalapu}. fejezetben ismertetett Bayes-döntés alapú diszkretizációs eljárást.
    \descitem{Felügyelet nélküli tanulás} Ne várjon címkézett adatokat, kizárólag a bemenet változói közötti összefüggéseket ismerje fel.
    \descitem{Automatikus adattípus} Ismerje fel a diszkrét és folytonos változókat a bemeneti adatsorban, és kezelje ennek megfelelően.
    \descitem{Konfigurálhatóság} A kezdeti konfiguráció megadható legyen, ilyenkor ne végezzen automatikus felismeréseket.
\end{enumerate}

\subsection{Használhatósági követelmények}
A felhasználói élmény javítását célozza, az emberi tényezők figyelembe vételére törekszik.

\begin{enumerate}[resume]
    \descitem{Felhasználók} A csomagot arra kell felkészíteni, hogy fejlesztők és adattudósok használhassák.
    \descitem{Bemeneti típusok} Legyen megadva a \textit{typing} modul segítségével a kezelt típusok. A python gyengén típusos nyelv, ezért ezt a nyelv nem kényszeríti ki, ám a fejlesztői környezetek felismerik és támogatják a típusokat, ezzel segítve a felhasználót.
    \descitem{Logolás} Támogassa a \textit{logging} modult. A logoló beállításait tartsa be és rögzítse a logban a folyamat lépéseit. A kezelt problémákat is jegyezze fel.
    \descitem{Robuszusság - bemenet} Ismerje fel a nem megfelelő bemenetet, és kezelje akár kivételt dobva.
    \descitem{Robuszusság - futás} Algoritmus futása közben fellépő kivételeket kezelje. A helytelen eredmény felismerése nem lehetséges, ezért ez nem is cél.
    \descitem{Ismert metódusok} Hasonlítson kiajánlott metódusok neve és működése a \textit{scikit-learn} csomag algoritmusaihoz. Ezzel segítve a felhasználók könnyebb alkalmazkodását.
    \descitem{Nyílt forráskód} Az implementáció legyen elérhető bárki számára.
\end{enumerate}

\subsection{Megbízhatósági követelmények}
A hibalehetőségek száma, gyakorisága és azok kezelésének lehetőségeit fogalmazza meg.

\begin{enumerate}[resume]
    \descitem{Belső hibák} A belső hibákat kapja el, logolja és csak saját hibákat dobjon. Ezzel elérhető, hogy a helyben kezelhető hibák ne okozzák az alkalmazás futásának a végét.
    \descitem{Determináltság} A futtatott algoritmus determinisztikus. Legyen teszt, amely ellenőrzi, hogy ugyanarra a bemenetre ugyanazt az eredményt adja.
    \descitem{Diszkretizáció hiba} A diszkretizáció során fellépő hibát kezelje úgy, hogy az eredeti diszkretizációt megtartja.
\end{enumerate}

\subsection{Teljesítmény követelmények}
A futási sebességet, hatékonyságot, pontosságot határozza meg

\begin{enumerate}[resume]
    \descitem{Dinamikus programozás} Használja ki, hogy az algoritmusban használt \textit{H} mátrix értéke dinamikus programozással megoldható
    \descitem{Futásidő - referencia} A futásidő legyen a tanulmányban szereplő \textit{Julia} implementációnál rövidebb ugyanarra a bemenetre.
    \descitem{Futásidő - bemenet} A bemeneti adatpontok számának függvényében $O(n^2)$ legyen.
\end{enumerate}

\subsection{Támogatottsági követelmények}
    Tesztelhetőségi, konfigurálhatósági, bővítési lehetőségekre ír le igényeket.

\begin{enumerate}[resume]
    \descitem{Egység teszt} Az algoritmus implementációjához és a használt segédfüggvényekhez legyenek működést ellenőrző tesztek.
    \descitem{Beállítható változó típus} Legyen megadható a bemeneti változók típusa (folytonos és diszkrét)
    \descitem{Beállítható kezdeti diszkretizáció} Lehessen megadni kezdeti diszkretizációt, vagy kiválasztani az ezt létrehozó algoritmust.
\end{enumerate}

\section{Felépítés}
A python nyelven készült függvénykönyvtárakat a nevezéktan két csoportra bontja. Egyik csoport a \textbf{modul}. Ebben az esetben egyetlen fájlban szerepel a kódbázis. Ilyenkor a fájl nevével lehet rá hivatkozni, ezzel emelhető be más programokba. A modulban szereplő minden elem a névtérbe kerül és a használó programban elérhető lesz.

A másik csoport \textbf{csomag}. Ilyenkor egy könyvtárban vannak összegyűjtve a funkciók. A kiajánlott osztályokat és függvényeket a \textit{\_\_main\_\_.py} tartalmazza. Ebben lehet bármilyen python kód, de általában \textit{import} hívások sorozata, amely a csomag fájljaiból, mint modulokból gyűjti össze a kívülről elérhető nyelvi elemeket. Más programokba a könyvtár nevével emelhető be, ilyenkor a kiajánlott funkciók lesznek a névtérben. A python nem támogatja a privát nyelvi elemeket, így ismerve egy csomag felépítését, annak moduljai is beemelhetőek, de ez gyanús kódot (code smell) eredményez.

A csomag a \textit{MultivariateDiscretizer.py} modul köré épül. Megvalósítható lett volna egyetlen modulban is, de a könnyebb bővíthetőség és olvashatóság érdekében több modulra lett bontva. Így később akár más nagyobb diszkretizációs eljárások is könnyen hozzáadhatók.

A fő modul, amely az algoritmust végrehajtó osztályt tartalmazza a \textbf{MultivariateDiscretizer}. Ebben található az azonos nevű osztály, mely példányosításkor várja az adatsort, melyből automatikusan képes beállítani a konfigurációját, valamint egyéb konfigurációs paraméterek is megadhatók. Ezen az elven működnek a \textit{scikit-learn} csomag implementációi is. A tanulás megkezdéséhez a \textit{fit} metódust kell meghívni, ez szintén azonos a hasonló csomagok használatával. Azért szükséges külön bontani az inicializálást és a tanulást, mert így mérhető a sebességük külön-külön is a felhasználó számára.

A Bayes-döntés alapú diszkretizációs eljárás implementációja a \textbf{discretization} modulban szerepel. Azért szerepel külön, mert így könnyen tesztelhető fejlesztés közben, hiszen futtatható a fájl önmagában is. Emellett több implementációt is vizsgáltam, és itt ezek együtt szerepelhetnek.

Egyéb segédfüggvényeket tartalmaz a \textbf{util} modul. Ezek nem szorosan kapcsolódnak az eljáráshoz, egyéb esetekben is hasznosak lehetnek, így ki lettek szervezve egy külön modulba. Ennek az előnye, hogy könnyen írható ezekre teszteset, hiszen a bemeneti paramétereik alapján determinisztikusak. A \textit{MultivariateDiscretizer} metódusai az osztályváltozókat is használják, így ezek teszteléséhez példányosítani kell az objektumot.

\begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{figures/app/structure.png}
    \caption{A rendszer felépítése}
    \label{fig:struktura-diagram}
\end{figure}

% TODO: tesztelési környezet hozzáadása

\section{Működés}
